name: Dev Commit (Random Times & Monthly Quota)

on:
  schedule:
    - cron: "30 2-17 * * *"  # Runs at 8:30 AM to 11:30 PM Sri Lanka time (UTC+5:30)
  workflow_dispatch:

jobs:
  auto-dev:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Grant write permission to the workflow

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}  # Use PAT from the start
          fetch-depth: 0

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Initialize progress tracker file
        run: |
          PROGRESS_FILE=".progress.json"
          
          # Check if progress file exists
          if [ ! -f "$PROGRESS_FILE" ]; then
            echo "Creating progress tracker file..."
            echo '{"frontend_completed":[],"backend_completed":[]}' > $PROGRESS_FILE
            
            # Configure git
            git config user.name "rasandu17"
            git config user.email "rasandu17@gmail.com"
            
            # Commit and push the progress file
            git add $PROGRESS_FILE
            git commit -m "Initialize progress tracker"
            git push origin main
            
            echo "‚úÖ Progress tracker created and committed"
          else
            echo "‚úÖ Progress tracker already exists"
          fi

      - name: Select instruction file (frontend first, then backend)
        id: pickfile
        run: |
          PROGRESS_FILE=".progress.json"
          
          # Create progress file if it doesn't exist (fallback safety)
          if [ ! -f "$PROGRESS_FILE" ]; then
            echo "‚ö†Ô∏è Progress file missing, creating it..."
            echo '{"frontend_completed":[],"backend_completed":[]}' > $PROGRESS_FILE
          fi
          
          # Get completed counts
          FRONTEND_DONE=$(jq -r '.frontend_completed | length' $PROGRESS_FILE)
          BACKEND_DONE=$(jq -r '.backend_completed | length' $PROGRESS_FILE)
          
          # Total instructions count
          FRONTEND_TOTAL=$(jq length ai_instructions.json)
          BACKEND_TOTAL=$(jq '.steps | length' ai_instructions_backend.json)
          
          # Decide which file to use
          if [ $FRONTEND_DONE -lt $FRONTEND_TOTAL ]; then
            # Frontend not finished, use it
            SELECTED_FILE="ai_instructions.json"
            echo "üì± Working on frontend ($FRONTEND_DONE/$FRONTEND_TOTAL completed)"
          elif [ $BACKEND_DONE -lt $BACKEND_TOTAL ]; then
            # Frontend done, work on backend
            SELECTED_FILE="ai_instructions_backend.json"
            echo "‚öôÔ∏è Working on backend ($BACKEND_DONE/$BACKEND_TOTAL completed)"
          else
            # Both done, reset and start over with frontend
            echo "üéâ All instructions completed! Starting over..."
            jq '.frontend_completed = [] | .backend_completed = []' $PROGRESS_FILE > tmp_progress.$$.json && mv tmp_progress.$$.json $PROGRESS_FILE
            SELECTED_FILE="ai_instructions.json"
            echo "üì± Restarting with frontend"
          fi
          
          echo "SELECTED_FILE=$SELECTED_FILE" >> $GITHUB_ENV
          echo "Selected file: $SELECTED_FILE"

      - name: Read instructions
        id: read
        run: |
          RAW_JSON=$(cat $SELECTED_FILE)
          
          # Check if it's the backend file with nested structure
          if [[ "$SELECTED_FILE" == "ai_instructions_backend.json" ]]; then
            INSTRUCTIONS=$(echo "$RAW_JSON" | jq -c '.steps')
          else
            # Frontend file is already an array
            INSTRUCTIONS="$RAW_JSON"
          fi
          
          echo "INSTRUCTIONS_B64=$(echo "$INSTRUCTIONS" | base64 -w 0)" >> $GITHUB_ENV
          echo "Instructions extracted successfully"

      - name: Setup daily quota
        run: |
          TODAY=$(date +%Y-%m-%d)
          QUOTA_FILE=".monthly_commit_quota.json"
          
          # Create quota file if it doesn't exist
          if [ ! -f "$QUOTA_FILE" ]; then
            echo '{}' > $QUOTA_FILE
          fi
          
          TODAY_DATA=$(jq -r ".\"$TODAY\"" $QUOTA_FILE)
          
          if [ "$TODAY_DATA" == "null" ]; then
            TODAY_DATA='{"commits_done":0,"commits_today_quota":3}'
            jq ". + {\"$TODAY\": $TODAY_DATA}" $QUOTA_FILE > tmp.$$.json && mv tmp.$$.json $QUOTA_FILE
          fi
          
          QUOTA=$(echo $TODAY_DATA | jq -r .commits_today_quota)
          DONE=$(echo $TODAY_DATA | jq -r .commits_done)
          
          echo "QUOTA=$QUOTA" >> $GITHUB_ENV
          echo "DONE=$DONE" >> $GITHUB_ENV
          echo "TODAY=$TODAY" >> $GITHUB_ENV
          echo "Today: $TODAY | Done: $DONE | Quota: $QUOTA"

      - name: Track progress and select next instruction (SEQUENTIAL)
        id: progress
        run: |
          PROGRESS_FILE=".progress.json"
          
          # Decode instructions
          INSTRUCTIONS=$(echo "$INSTRUCTIONS_B64" | base64 --decode)
          TOTAL_COUNT=$(echo "$INSTRUCTIONS" | jq length)
          
          # Determine which completion array to use
          if [[ "$SELECTED_FILE" == "ai_instructions_backend.json" ]]; then
            COMPLETED_KEY="backend_completed"
          else
            COMPLETED_KEY="frontend_completed"
          fi
          
          # Get completed instruction indices
          COMPLETED=$(jq -r ".$COMPLETED_KEY | @json" $PROGRESS_FILE)
          COMPLETED_ARRAY=$(echo "$COMPLETED" | jq -r '.[]' | tr '\n' ' ')
          
          # Find the FIRST uncompleted instruction (sequential order: 0, 1, 2, 3...)
          SELECTED_INDEX=-1
          for i in $(seq 0 $((TOTAL_COUNT - 1))); do
            if ! echo "$COMPLETED_ARRAY" | grep -qw "$i"; then
              SELECTED_INDEX=$i
              break
            fi
          done
          
          # If all completed, reset and start over from 0
          if [ $SELECTED_INDEX -eq -1 ]; then
            echo "All instructions completed! Resetting progress..."
            jq ".$COMPLETED_KEY = []" $PROGRESS_FILE > tmp_progress.$$.json && mv tmp_progress.$$.json $PROGRESS_FILE
            SELECTED_INDEX=0
            REMAINING=$TOTAL_COUNT
          else
            # Count remaining
            COMPLETED_COUNT=$(echo "$COMPLETED" | jq 'length')
            REMAINING=$((TOTAL_COUNT - COMPLETED_COUNT))
          fi
          
          echo "SELECTED_INDEX=$SELECTED_INDEX" >> $GITHUB_ENV
          echo "COMPLETED_KEY=$COMPLETED_KEY" >> $GITHUB_ENV
          echo "üìç Selected instruction #$SELECTED_INDEX ($REMAINING remaining in order)"

      - name: Decide whether to commit this run
        id: randomcommit
        run: |
          if [ $DONE -ge $QUOTA ]; then
            echo "DO_COMMIT=false" >> $GITHUB_ENV
            echo "Quota reached for today ($DONE/$QUOTA)"
          else
            RANDOM_CHANCE=$((RANDOM % 100))
            if [ $RANDOM_CHANCE -lt 50 ]; then
              echo "DO_COMMIT=true" >> $GITHUB_ENV
              echo "Random check passed - will commit"
            else
              echo "DO_COMMIT=false" >> $GITHUB_ENV
              echo "Random check failed - skipping commit (instruction #$SELECTED_INDEX will be tried again next time)"
            fi
          fi

      - name: Run commit if selected
        if: env.DO_COMMIT == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          # Decode instructions
          INSTRUCTIONS=$(echo "$INSTRUCTIONS_B64" | base64 --decode)
          
          # Use the selected index from progress tracking
          STEP=$(echo "$INSTRUCTIONS" | jq -c .[$SELECTED_INDEX])
          
          # Extract fields - handle both frontend and backend structures
          if [[ "$SELECTED_FILE" == "ai_instructions_backend.json" ]]; then
            FILE_PATH="Server/$(echo $STEP | jq -r '.output_files[0]')"
            DESC=$(echo $STEP | jq -r .description)
            TITLE=$(echo $STEP | jq -r .title)
          else
            FILE_PATH="Client/$(echo $STEP | jq -r .file)"
            INSTRUCTION=$(echo $STEP | jq -r .instruction)
            
            # Generate natural commit title based on the instruction
            TITLE=$(echo "$INSTRUCTION" | sed 's/^Create /Add /' | sed 's/^Build /Implement /' | sed 's/^Design /Create /' | sed 's/\. .*$//')
            DESC="$INSTRUCTION"
          fi
          
          echo "Working on: $TITLE"
          echo "File: $FILE_PATH"
          echo "Instruction: $DESC"
          
          # Call Gemini API with better prompt
          RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
{
  "contents": [{
    "parts": [{
      "text": "You are a coding assistant. Generate ONLY the code, no explanations, no markdown formatting.\n\nTask: $DESC\n\nRequirements:\n- Output ONLY valid, working code\n- NO markdown code blocks\n- NO explanations\n- Just raw code\n\nGenerate the code now:"
    }]
  }]
}
EOF
          )
          
          echo "API Response received"
          
          # Extract code from response
          CODE=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')
          
          # Check if CODE is empty
          if [ -z "$CODE" ] || [ "$CODE" == "null" ]; then
            echo "‚ùå Error: Gemini API returned empty response"
            echo "Full response: $RESPONSE"
            exit 1
          fi
          
          echo "Code extracted, length: ${#CODE} characters"
          
          # Remove markdown code blocks if present (multiple patterns)
          CODE=$(echo "$CODE" | sed 's/^```[a-zA-Z]*$//' | sed 's/^```$//' | sed '/^```[a-zA-Z]*$/d' | sed '/^```$/d')
          CODE=$(echo "$CODE" | sed '1{/^```/d}' | sed '${/^```/d}')
          
          # Trim leading/trailing whitespace
          CODE=$(echo "$CODE" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          
          echo "Code cleaned, final length: ${#CODE} characters"
          
          # Create directory if needed
          if [ ! -f "$FILE_PATH" ]; then
            mkdir -p $(dirname "$FILE_PATH")
            echo "Created new file: $FILE_PATH"
          else
            echo "Updating existing file: $FILE_PATH"
          fi
          
          # Save code to file
          echo "$CODE" > "$FILE_PATH"
          
          # Verify file was created with content
          if [ ! -s "$FILE_PATH" ]; then
            echo "‚ùå Error: File is empty after writing"
            exit 1
          fi
          
          FILE_SIZE=$(wc -c < "$FILE_PATH")
          echo "‚úÖ File created successfully: $FILE_PATH ($FILE_SIZE bytes)"
          
          # Configure git with your GitHub username and email
          git config user.name "rasandu17"
          git config user.email "rasandu17@gmail.com"
          
          # Mark this instruction as completed in progress file
          echo "Marking instruction #$SELECTED_INDEX as completed..."
          jq ".$COMPLETED_KEY += [$SELECTED_INDEX] | .$COMPLETED_KEY |= unique | .$COMPLETED_KEY |= sort" .progress.json > tmp_progress_new.$$.json && mv tmp_progress_new.$$.json .progress.json
          
          # Verify the update
          echo "Progress file updated:"
          cat .progress.json
          
          # Update commits_done counter
          jq ".\"$TODAY\".commits_done += 1" .monthly_commit_quota.json > tmp_quota.$$.json && mv tmp_quota.$$.json .monthly_commit_quota.json
          
          # Add the generated code, progress tracker, and quota file in one commit
          git add "$FILE_PATH" .progress.json .monthly_commit_quota.json
          
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "$TITLE" -m "$DESC"
          git push origin main
          
          echo "‚úÖ Successfully pushed changes"
